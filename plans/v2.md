# Rehoboam-Inspired Circular UI V2 Specification for a React/Vite Stack

## Visual and interaction characteristics of the Rehoboam UI pattern

In Westworld Season 3-era “Rehoboam-style” visuals, the dominant motif is a **circular timeline and/or circular “world model”**: key moments (“divergences”) appear as **spikes / peaks** protruding from a ring, paired with on-screen labels and system-like status language. This is explicit in coverage of the Season 3 date-announcement/Divergence teaser (events listed around a circle, then “system initiated” and later a “critical event”). citeturn14view0turn20view0turn14view2

A key behavior in the Divergence teaser is the “callout” grammar: **a label appears, and a graphics “marker”/line indicates a specific point on the circular timeline**, typically landing on a visibly **pulsing peak**; the sequence progresses around the circle as more events are called out. citeturn20view1

Inside the actual Season 3 episodes, the UI language is framed as an omniscient monitoring system: interstitial graphics are described as reporting “**Divergences**, **Anomalies**, and **Elevated Scrutiny**,” reinforcing that the visuals are not decorative but a system’s internal status readout. citeturn9view1

A practical implication for your V2 UI/UX: **the “Rehoboam” motion language sells a feeling of continuous computation**—slow, layered movement with occasional emphatic pulses when an event “trips” the system (divergence/anomaly). Commentary around the show notes a deliberate desire to convey “what it’s watching / thinking” and to orient the viewer in the world using divergence pinpoints, which translates cleanly to your app’s “current world events” concept. citeturn9view0

Finally, behind-the-scenes and practitioner discussions of screen-graphics work for Westworld emphasize two implementable design constraints that are highly relevant to agentic implementation: (1) **information hierarchy** (what matters must be immediately legible; everything else becomes textured “data atmosphere”), and (2) **motion/interaction built around the shot/story**, often requiring designers to pre-plan “hero” moments, then fill the world with a consistent library of secondary elements. citeturn4search0turn16view2

## Curated reference pack

This is a short “best-of” set to anchor V2 decisions. Each item is chosen because it demonstrates a specific primitive you can translate into code.

**Circular timeline + labeled divergences (core grammar)**

- entity["organization","Motion Picture Association","trade association, us"] “The Credits” article describing the Season 3 date announcement video: lists divergences around a timeline and explicitly calls out “system initiated” (Solomon build) and later “critical event.” This supports the **ring-as-timeline** model and the **system status narrative**. citeturn14view0
- entity["company","Tom's Guide","tech media site, us"] coverage noting the trailer is “centered around Divergence” and that it presents a timeline culminating in “system initiated” and a later critical divergence. This supports **timeline progression**, **labeling**, and **story-driven event selection**. citeturn20view0
- entity["company","Business Insider","news outlet, us"] coverage of the premiere date teaser confirms the teaser video reveals the timeline and diverges into a “system” initiated later, reinforcing the canonical “divergence” framing. citeturn14view2

**Event peaks + drawn markers (micro-interaction you should replicate)**

- Shat on TV post describing the Divergence teaser’s presentation: labels map to **pulsating peaks** and a **marker is quickly drawn** between the description and the peak; events appear to trace around the circle. This supports your implementation of **event callouts**, **animated leader lines**, and **peak pulses**. (Treat as an observational reference, not a canonical production document.) citeturn20view1

**Episode interstitial semantics (naming, states, categories)**

- entity["organization","Den of Geek","entertainment media site, us"] describes that episode interstitials likely represent internal system readouts and specifically name “Divergences,” “Anomalies,” and “Elevated Scrutiny,” which directly maps to a UI state machine for your V2. citeturn9view1

**“Watching/thinking” framing and geo pinpoints (how to integrate events meaningfully)**

- entity["people","Jonathan Nolan","tv showrunner"] is quoted describing divergence pinpoints helping orient the audience and conveying what the presence is watching/thinking. This supports: (a) your ring should feel like a live intelligence model, and (b) events need metadata (geo, severity, category) to drive visuals. citeturn9view0

**Screen-graphics production constraints (why the UI must be layered + hierarchical)**

- entity["people","Noah Schloss","screen graphics designer"] interview describing creating screen graphics for Rehoboam and the need for hierarchy—primary info on hero screen, secondary info elsewhere; also discusses using shape/color “language” to organize complexity. This supports your layer decomposition into “hero” vs “atmosphere.” citeturn4search0turn1view0
- entity["people","Chris Kieffer","screen graphics supervisor"] interview describing workflow: pre-defining style, palette, functionality; identifying “hero” elements; sometimes requiring post/VFX to match interaction and depth/parallax; and the need to reverse-engineer interaction if gestures aren’t planned. This supports your decision to **spec interaction first**, then implement motion consistently. citeturn16view2

## Implementable visual spec

This is the core deliverable: a layer-by-layer spec with measurable parameters and implementable triggers. It is “inspired by” the show’s interface language (ring timeline + divergence semantics) without copying show assets. citeturn14view0turn20view1turn9view1

### Coordinate system and scaling

**Canvas space**

- Let `W,H` be the render surface size in CSS pixels.
- Let `dpr = clamp(window.devicePixelRatio, 1, 2)` (cap to 2 for predictable performance).
- Let `R = 0.46 * min(W, H)` be the “outer radius” of the ring stack.
- Center is `C = (W/2, H/2)`.

**Polar helpers**

- Angle `θ` in radians; `θ=0` at 12 o’clock (north), increasing clockwise (this matches typical “dial” expectations and makes event placement intuitive for timelines).
- Conversion:
  - `x = Cx + r * sin(θ)`
  - `y = Cy - r * cos(θ)`

### Visual layers and primitives

Below, each layer includes: look, motion, triggers, recommended implementation, and measurable defaults.

**Layer 0: Composition frame + safe area**

- **Look:** A centered “instrument” area that never touches edges; UI feels like it’s “on glass.”
- **Motion:** None; purely layout.
- **Triggers:** Resize only.
- **Implementation:** React layout + `ResizeObserver` to drive renderer sizing. citeturn18search1
- **Defaults:**
  - Safe margin: `m = max(16px, min(W,H)*0.06)`
  - Instrument rect: `W-2m, H-2m`

**Layer 1: Background field (subtle grain + radial wash)**

- **Look:** Extremely subtle monochrome texture that prevents flatness; optionally a faint radial gradient “hotspot” behind the core.
- **Motion:** Very slow drift (noise offset) to avoid static banding.
- **Triggers:** Always-on (idle loop); pauses when tab is backgrounded (browser will typically throttle/pause animation loops). citeturn18search0
- **Implementation:**
  - Best: Canvas2D with a pre-generated noise tile (e.g., 128×128) repeated and alpha-blended.
  - Alternative: CSS overlay using `mix-blend-mode` and a repeating background image. citeturn23search0
- **Defaults:**
  - Noise alpha: `0.03–0.06` (theme-dependent)
  - Drift speed: `8–16px/min` (imperceptible but alive)

**Layer 2: Base ring stack (the “Rehoboam-like core”)**

- **Look:** Concentric circles of varying thickness and opacity, including:
  - solid rings
  - dashed rings
  - segmented arc bands
  - fine tick rings  
    This is the main primitive that sells “computation.” citeturn14view0turn20view1
- **Motion:** Multiple independent rotations at different speeds/directions to create moiré-like dynamics without heavy effects.
- **Triggers:** Idle loop; subtle “breathing” pulses every few seconds.
- **Implementation:** Canvas2D strokes and arcs. Use dashed lines via `setLineDash()` and animate phase via `lineDashOffset`. citeturn23search3turn23search10
- **Measurable defaults:**
  - Ring count: `N = 22` (range 16–30 depending on perf budget)
  - Radii: evenly distributed from `0.18R` to `R` with slight jitter (±0.006R) to avoid mechanical spacing
  - Thickness (px): sampled from `[0.6, 0.8, 1.2, 1.6, 2.4, 3.2]`
  - Alpha per ring: `0.06–0.30`
  - Rotation speeds:
    - inner third: `±(2–6) deg/s`
    - middle third: `±(6–14) deg/s`
    - outer third: `±(10–22) deg/s`
  - Pulse: every `1800ms` (±250ms jitter), alpha scale `×1.25` for `240ms` with ease-out

**Layer 3: “Divergence waveform” overlay (controlled perturbations)**

- **Look:** A ring that can deform or spike locally—used to represent “divergence/anomaly” moments without turning into particles everywhere. This is the key semantic bridge from “world events” to ring behavior. citeturn20view1turn9view1
- **Motion:**
  - Baseline: subtle traveling ripples around (like a living signal).
  - Divergence: localized amplitude swell (fast rise, slower decay) near an event angle.
- **Triggers:**
  - New event arrival: create a divergence pulse at that event’s angle.
  - Severity change: re-pulse.
- **Implementation:**
  - Canvas2D polyline in polar coordinates: sample `S` points around the ring, compute radius offset `dr(θ,t)` from layered sin/noise + event pulses, then stroke.
  - (Optional) Use community-derived technique: counter-rotating waves + localized windowing for divergence shaping; treat as inspiration for an implementable algorithmic approach. citeturn21search1
- **Defaults:**
  - Wave ring radius: `rWave = 0.92R`
  - Samples: `S = 720` (1 point per 0.5°) on high perf, `S = 360` on low perf
  - Baseline amplitude: `0.002R`
  - Divergence pulse amplitude: `severityScaled * (0.010R–0.040R)`
  - Pulse envelope: attack `120ms`, decay `1400ms`
  - Window: raised cosine / Tukey-like, width `±8°` to `±18°` depending on severity

**Layer 4: Sweep/scan and crosshair cues (time + attention)**

- **Look:**
  - A faint sweeping line (clock-hand) or arc highlight that rotates slowly.
  - Optional crosshair ticks at cardinal directions.
- **Motion:** Continuous rotation with very slow speed; occasionally accelerates during “focus” interactions.
- **Triggers:**
  - Idle: constant.
  - Hover/select event: sweep snaps to the event angle, then eases back to constant drift.
- **Implementation:** Canvas2D line + gradient; composite via additive-like modes (see Layer 7 note). Use `requestAnimationFrame` loop for consistent timing. citeturn18search0turn18search4
- **Defaults:**
  - Sweep speed: `8 deg/s` (45s per revolution)
  - “Snap” easing: `cubic-bezier(0.16, 1, 0.3, 1)`
  - Snap duration: `260ms`

**Layer 5: Event ring markers (your “current world events” on the circle)**

- **Look:** Events appear as “peaks” or ticks on the outer ring—matching the Divergence teaser’s peaks on the outside of the circle. citeturn20view1turn14view0turn14view2
- **Motion:**
  - On insert: marker grows outward quickly; subtle pulse once.
  - On idle: slow “breathing” via alpha, or minimal height wobble (<10%).
- **Triggers:** New event arrival, updates, user focus.
- **Implementation:**
  - Canvas2D: draw small radial lines/triangles at angle `θEvent`, from `R*0.98` to `R*0.98 + h`.
  - Use a separate “event marker” pass so it can be re-rendered cheaply when only events change.
- **Defaults:**
  - Max events displayed in ring at once: `E = 48` (beyond that, cluster/aggregate)
  - Marker height `h` by severity:
    - low: `0.010R`
    - medium: `0.020R`
    - high: `0.032R`
    - critical: `0.045R`
  - Marker stroke: `1.0–2.0px` (scaled by `dpr`)
  - Insert animation: `220ms` grow + `480ms` fade settle

**Layer 6: Callouts + leader lines (hero readability)**

- **Look:** When an event is “spoken” by the system (new, hovered, or selected), show:
  - a leader line from the marker toward a text block
  - a small circle/diamond node on the ring where the line anchors
  - minimal uppercase label (title, time, category, severity)  
    This directly matches the observational description of label → drawn marker → pulsating peak. citeturn20view1
- **Motion:**
  - Line draws from ring outward (stroke-dashoffset animation conceptually).
  - Text fades/slides in subtly.
- **Triggers:**
  - New event: auto-callout for top severity event.
  - Hover: show callout after `120ms` dwell.
  - Selection: persistent callout.
- **Implementation:** DOM/SVG overlay for crisp text + easy hit targets; optionally draw leader line in Canvas2D for consistent blending, but keep text in DOM for accessibility and subpixel clarity.
- **Defaults:**
  - Callout max visible: `1 selected + 1 hinted` (avoid clutter)
  - Auto-callout duration: `3200ms` then collapse to marker-only
  - Typographic styling: uppercase, letter-spacing `0.12em`, font-size `11–13px` at `min(W,H)=900`, scale linearly down to `10px` at `min=420`

**Layer 7: Glow, additive blending, and compositing rules**

- **Look:** The show’s screen graphics often read as “light on glass.” In a web implementation, that typically means subtle additive blending and controlled blur—never full neon. citeturn16view2turn4search0
- **Motion:** Tied to pulses, divergence events, and focus states.
- **Triggers:** event insertion, hover/selection, system state changes.
- **Implementation:**
  - Canvas2D compositing: use `globalCompositeOperation` to layer “glow pass” over “base pass.” citeturn17search1turn17search21
  - Glow can be faked with Canvas shadows (`shadowBlur`, `shadowColor`) for small strokes only. citeturn23search2turn23search6
  - DOM overlays can use `filter: blur()` or `drop-shadow()` carefully; note that filter behavior can be browser-sensitive. citeturn23search9turn23search1turn23search28
- **Defaults (practical budgets):**
  - Glow strokes: only on 3–5 “hero” primitives at once (selected event marker, active callout node, divergence wave)
  - `shadowBlur`: 6–14 (scaled by `dpr`) and never applied to all rings simultaneously
  - Composite modes:
    - Base rings: normal
    - Glow pass: “lighter” (Canvas) or blended overlay (DOM) depending on your look target

**Layer 8: Interaction model (how users manipulate the system)**

- **Look:** Cursor/hover reveals intent; selection “locks” the system; zoom is a controlled camera move (not a chaotic pan). The show’s framing is about the system watching, not the user freely drawing. citeturn9view0turn9view1
- **Triggers:** pointer hover, click/tap, scroll/trackpad/pinch.
- **Implementation:** Pointer events unify mouse/pen/touch input. citeturn18search3turn18search19
- **V2 interactions (spec):**
  - **Hover marker:** highlight marker (alpha ×1.6), show callout after 120ms dwell.
  - **Click marker:** selection mode: ring rotates so selected marker moves to 12 o’clock, then camera zooms slightly and locks callout.
  - **Scroll wheel / pinch:** zoom in/out between 1.0 and 1.8 scale; selection persists unless user hits Escape/back.
  - **Drag:** rotates timeline (scrub) only when zoomed-in or with modifier key (prevents accidental spins).
- **Measurable defaults:**
  - Rotation snap duration: `260ms`
  - Zoom duration: `420ms`
  - Zoom range: `[1.0, 1.8]`
  - Drag sensitivity: `0.006 rad/px` (tunable)
  - Event selection hit target: >= `24px` radius in screen space (DOM overlay hit areas)

### Parameter table (single place to tune)

| Parameter            |         Default |     Range | Notes                              |
| -------------------- | --------------: | --------: | ---------------------------------- |
| `dprCap`             |             2.0 |   1.5–2.0 | Cap DPR for stable perf            |
| `ringCount`          |              22 |     16–30 | Reduce on low-power                |
| `outerRadius`        | `0.46*min(W,H)` |         — | Called `R`                         |
| `baseRotationInner`  |       2–6 deg/s |      0–10 | Alternating directions             |
| `baseRotationOuter`  |     10–22 deg/s |      0–30 | Outer rings read as “busier”       |
| `pulseIntervalMs`    |            1800 |  900–2600 | Add ±250ms jitter                  |
| `eventMaxVisible`    |              48 |     24–96 | Beyond: cluster                    |
| `divergenceAttackMs` |             120 |    80–180 | Fast rise                          |
| `divergenceDecayMs`  |            1400 |  800–2400 | Slow fall                          |
| `waveSamples`        |             720 |   240–720 | Budget knob                        |
| `calloutAutoMs`      |            3200 | 1500–6000 | Auto-callout lifetime              |
| `hoverDwellMs`       |             120 |    80–250 | Prevent flicker                    |
| `cameraZoomMax`      |             1.8 |   1.4–2.2 | Keep readable                      |
| `frameBudgetMs`      |              16 |         — | 60fps target citeturn18search12 |

### ASCII layer diagram (render order)

```text
Top (user sees / interacts with)
┌───────────────────────────────────────────────┐
│ DOM Overlay: Callouts + Labels + Hit Targets  │  (Layer 6, accessibility-friendly)
├───────────────────────────────────────────────┤
│ Canvas FX: Glow Pass + Divergence Wave        │  (Layers 3,7)
├───────────────────────────────────────────────┤
│ Canvas Main: Base Rings + Sweep + Event Marks │  (Layers 2,4,5)
├───────────────────────────────────────────────┤
│ Canvas Back: Grain / Radial Wash              │  (Layer 1)
└───────────────────────────────────────────────┘
Bottom
```

## Rendering strategy decision

You asked for an optimal approach **on top of your existing React SPA**, not a greenfield rewrite. The core tradeoff is: SVG is wonderful for small numbers of vector elements and DOM integration, but a faithful ring system typically wants many layered primitives with continuous motion and blending.

### Comparison: SVG vs Canvas2D vs WebGL

**SVG (retained-mode vectors)**

- Strengths: crisp vector edges, built-in hit testing and accessibility via DOM, easy text layout. Retained mode means you can target individual elements for events/updates. citeturn17search6
- Weaknesses: thousands of animated SVG nodes (rings, ticks, particles) can become expensive; glow/blur filters can be heavy; blending across many layers can be tricky. (General retained/DOM cost patterns apply.) citeturn17search6

**Canvas2D (immediate mode)**

- Strengths: excellent for many lightweight primitives; you control redraw and can keep a tight render loop; blending via `globalCompositeOperation` and dash patterns via `setLineDash()` are straightforward. citeturn17search9turn17search1turn23search3
- Weaknesses: no built-in hit testing; you must implement picking; text rendering is possible but often better in DOM for crispness and accessibility. citeturn17search6turn24search4
- Performance note: you can use `OffscreenCanvas` to move render work off the main thread where supported, reducing UI jank. citeturn17search0turn17search4

**WebGL (GPU rendering via canvas)**

- Strengths: best for shader-driven glow/grain/distortion at scale; ideal if you later want high-quality bloom/noise and very high ring counts. WebGL is available via the canvas WebGL context. citeturn17search3
- Weaknesses: higher implementation complexity; text still best as DOM; debugging and testability are harder without discipline.

### Recommendation for your V2

**Best default (recommended): Hybrid Canvas2D + DOM/SVG overlay**

- Canvas2D renders Layers 1–5 and most of 7 (rings, divergence waves, sweep, event markers, glow pass).
- DOM (optionally with small SVG for leader lines) renders Layer 6 (callouts/labels/hit targets).
- This matches screen-graphics practice: a “hero” readable layer atop a rich background system. citeturn4search0turn16view2
- Use `requestAnimationFrame()` for the engine loop. citeturn18search0turn18search4
- Optional performance upgrade: `OffscreenCanvas` renderer in a worker for the heaviest passes. citeturn17search0turn17search4

**Fallback / simpler variant: Enhanced SVG-only**

- Keep your existing SVG circle and implement:
  - fewer rings (8–12)
  - CSS/SVG animations for rotation
  - minimal event markers
- This will not achieve the same density or composited “compute atmosphere,” but is the simplest incremental step if you want minimal engine code. The retained vs immediate distinction is a useful mental model here. citeturn17search6

**Future upgrade path: WebGL renderer for “FX fidelity”**

- If you later want bloom-like glow, film-grain, and distortion without large CPU cost, adopt a WebGL 2D renderer (custom or library). The WebGL context is standardized via `getContext("webgl")` / `getContext("webgl2")`. citeturn17search3turn17search7
- Keep the same engine/data boundary so swapping render backends doesn’t force a rewrite.

## Architecture and data/event system

This section proposes a repo architecture and runtime architecture that (a) preserves your current React SPA approach, and (b) makes V2 implementable by agentic coding tools with minimal back-and-forth.

### Runtime architecture (data → layout → renderer)

**Data flow overview**

- `EventSources` fetch/parse world events (client-only or via optional serverless).
- Events are normalized into a stable `WorldEvent[]` model.
- A `Layout` module maps events → ring positions (angles, clusters, callout candidates).
- A `Renderer` module renders frames from `RenderState + LayoutOutput`.
- React owns DOM overlay (callouts, toolbars, event list), and passes interaction state into the engine.

**Why this split works**

- You can unit-test parsing/layout without a browser canvas.
- The renderer can remain mostly deterministic and “pure” given inputs (time, state, layout), which helps both testing and agent implementation.

### Proposed module layout (repo folders)

```text
src/
  app/
    app.tsx
    routes.tsx
  features/rehoboam/
    rehoboam-scene.tsx         # orchestrates canvases + overlay + engine
    overlay/
      callout-overlay.tsx
      event-list-panel.tsx
    engine/
      create-engine.ts         # lifecycle + RAF + resize + input
      types.ts                 # render/layout types
      time.ts                  # clock abstraction (testable)
      input.ts                 # pointer/keyboard mapping
    render/
      canvas2d/
        renderer-2d.ts         # draw passes
        passes/
          background-pass.ts
          rings-pass.ts
          divergence-pass.ts
          event-marks-pass.ts
          glow-pass.ts
      picking/
        hit-test.ts            # angle/radius picking + spatial index
    layout/
      compute-angles.ts
      cluster-events.ts
      choose-callout.ts
    data/
      sources/
        rss-source.ts
        json-source.ts
      normalize.ts
      dedupe.ts
      store.ts                 # event store (zustand or custom)
  shared/
    hooks/
      use-resize-observer.ts    # ResizeObserver wrapper citeturn18search1
      use-raf-loop.ts           # requestAnimationFrame wrapper citeturn18search0
    utils/
      math.ts                   # polar helpers
      easing.ts                 # cubic-bezier helpers
  tests/
    layout/*.test.ts
    data/*.test.ts
    render/*.test.ts            # invariants / command tests
```

### Render loop strategy

- Use `requestAnimationFrame()` for the continuous motion loop; browsers generally align callback frequency to display refresh rate and pause in background tabs, which is good for battery/perf. citeturn18search0turn18search4
- Maintain a frame budget targeting ~16ms for 60fps; treat any feature that regularly breaches this as an explicit “quality tier” knob. citeturn18search12
- Size canvases using `ResizeObserver` instead of window resize alone (supports responsive containers). citeturn18search1

### Interaction input strategy

- Use Pointer Events (`pointerdown/move/up`) to unify mouse/pen/touch interactions. citeturn18search3turn18search19
- Implement ring picking with a simple transform: convert pointer point to polar `(r, θ)` around center, then detect nearest marker by angular distance with tolerance.
- Keep DOM hit targets for markers/callouts when feasible (accessibility and device friendliness).

### Event/data system for “current world events”

The show’s circular timeline explicitly associates “divergences” with world events. Your app can borrow the semantics: events become ring peaks; the system “watches” and flags anomalies. citeturn14view0turn9view1turn20view1

**Event model (recommended fields)**

- `id` (stable hash)
- `title`
- `timestamp` (ms) and optionally `timeRange`
- `category` (enum)
- `severity` (0–1 continuous + label buckets)
- `source` (publisher/feed)
- `url` (optional; do not embed media)
- `geo` (optional: lat/lon + place label)
- `relatedEntities[]` (strings; your own concept of entities)

**Mapping events onto the ring**

- **Angle**: map time to angle on a sliding window (e.g., last 24h = full circle) or an ordered queue for “now.”
- **Peak height**: severity.
- **Peak pulse frequency**: severity and recency (more recent/high severity pulses more).
- **Callout selection**: newest high severity, or user selected; match the teaser’s “event is labeled + pointed to.” citeturn20view1

**Dedupe/refresh strategy**

- Dedupe key: `hash(normalizedTitle + canonicalUrl + floor(timestamp/30min) + source)`
- Refresh interval: 60–180 seconds (configurable).
- When refreshed:
  - existing event updated → “soft pulse”
  - truly new event → “insert animation” + divergence pulse

**Offline/dev mock strategy**

- Always ship a `mockEvents.json` fixture for deterministic development (supports agentic coding and tests).
- Seeded RNG for any procedural motion so visuals are reproducible across runs (critical for visual regression).

**Option A: purely client-side fetch (minimal infra)**

- Use `fetch()` to get RSS/JSON from allowed endpoints; respect CORS constraints. citeturn19search10
- Use HTTP caching and/or the Cache API for short-term caching. citeturn19search0turn19search4turn19search6
- Store normalized events in IndexedDB for persistence and offline rehydration. citeturn19search5turn19search9turn19search32

**Option B: lightweight serverless aggregator (recommended for reliability)**

- A scheduled job (cron) pulls multiple feeds, normalizes/dedupes server-side, stores in a small DB/object store, and exposes a single JSON endpoint to the SPA.
- Benefits: avoids CORS issues, consistent rate limits, stable uptime.
- Keep cloud-agnostic: any serverless + cron + KV/DB works.
- Do not rely on Periodic Background Sync as a core requirement; it is explicitly marked experimental and supporting behavior is browser-dependent. citeturn19search3turn19search11

## Agent-friendly implementation plan

This section turns the spec into execution-ready milestones, tasks, interfaces, and prompts.

### Milestone roadmap

**MVP milestone (functional Rehoboam-like ring + events)**

- Canvas2D ring stack (Layer 2) with 16–22 rings, continuous rotation, basic pulses.
- Event model + mock feed; map events to outer ring markers (Layer 5).
- Hover/select interactions with a single callout overlay (Layer 6).
- Basic layout responsiveness with `ResizeObserver`. citeturn18search1

**V2 milestone (faithful semantics + divergence language)**

- Divergence waveform ring (Layer 3) triggered on new events.
- Sweep/scan cues (Layer 4) that snap to selection.
- Auto-callout “system speaks” behavior for new high-severity events, echoing teaser grammar. citeturn20view1
- Caching + persistence: Cache API + IndexedDB. citeturn19search0turn19search5

**Polish milestone (production-level motion + performance)**

- Glow pass tuned to perf budget; quality tiers. citeturn17search1turn23search2
- Optional OffscreenCanvas worker renderer for heavy passes. citeturn17search0turn17search4
- Visual regression tests (Playwright) + reduced nondeterminism. citeturn25search0turn25search21
- Accessibility: keyboard navigation for event list + accessible fallback for canvas-driven UI. citeturn24search17turn24search3

### Task list with acceptance criteria

**Task: Build the render-engine boundary**

- Acceptance: an `Engine` can `start()`, `stop()`, `resize()`, `setEvents()`, `setInteraction()`, and renders frames via RAF with a stable time source. citeturn18search0
- Acceptance: resizing uses `ResizeObserver` and updates DPR-scaled canvas dimensions. citeturn18search1

**Task: Implement Layer 2 rings pass**

- Acceptance: given `ringCount=22`, rings animate with alternating directions and distinct speeds; no dropped frames on a typical laptop at `dpr<=2` (subjective manual check). citeturn18search12
- Acceptance: dash patterns use `setLineDash`, phase animated via `lineDashOffset`. citeturn23search3turn23search10

**Task: Implement event marker mapping**

- Acceptance: events appear as outer ring peaks with severity-based height, and new events animate in with grow + pulse as specified. citeturn20view1

**Task: Implement callout overlay**

- Acceptance: hover shows callout after dwell; click locks; Escape clears selection.
- Acceptance: leader line animation “draws” outward (DOM/SVG stroke-dashoffset or Canvas).
- Acceptance: callout shows title, timestamp, category, severity.

**Task: Implement divergence waveform**

- Acceptance: new event triggers localized radial perturbation with fast rise and slow decay. citeturn9view1turn21search1

**Task: Event fetch + normalize + dedupe**

- Acceptance: parsing code supports at least one JSON endpoint + mock file; dedupe key prevents duplicates across refresh.
- Acceptance: offline rehydration via IndexedDB works. citeturn19search5turn19search9

### TypeScript model and engine interfaces (copy/paste)

```ts
// src/features/rehoboam/engine/types.ts

export type EventCategory =
  | "conflict"
  | "politics"
  | "economy"
  | "technology"
  | "climate"
  | "health"
  | "security"
  | "unknown";

export type SeverityLabel = "low" | "medium" | "high" | "critical";

export interface GeoPoint {
  lat: number;
  lon: number;
  label?: string; // e.g., "Paris, FR"
}

export interface RelatedEntity {
  id: string; // stable internal id (e.g., hash)
  name: string; // display name
  kind?: "person" | "org" | "place" | "topic" | "unknown";
}

export interface WorldEvent {
  id: string; // stable dedupe id
  title: string;
  timestampMs: number; // epoch ms
  category: EventCategory;
  severity: number; // 0..1
  severityLabel: SeverityLabel;
  source: {
    name: string;
    url?: string;
  };
  url?: string; // canonical link if available
  geo?: GeoPoint;
  related?: RelatedEntity[];
  summary?: string;
  updatedAtMs?: number;
}

export interface ViewportState {
  widthCssPx: number;
  heightCssPx: number;
  dpr: number; // capped
}

export interface CameraState {
  rotationRad: number; // rotates timeline so selection can snap to 12 o'clock
  zoom: number; // 1..cameraZoomMax
  panX: number; // css px (usually 0)
  panY: number;
}

export interface InteractionState {
  pointer: {
    x: number;
    y: number;
    isDown: boolean;
  } | null;
  hoveredEventId: string | null;
  selectedEventId: string | null;
  mode: "idle" | "hover" | "selected" | "scrub";
}

export interface RenderTheme {
  // Keep “inspired by” palette configurable without copying show assets.
  background: string; // css color
  ink: string; // primary stroke/text color
  accent: string; // highlight color
  grainAlpha: number; // 0..1
}

export interface EngineInputs {
  nowMs: number;
  viewport: ViewportState;
  camera: CameraState;
  interaction: InteractionState;
  events: readonly WorldEvent[];
  theme: RenderTheme;
}

export interface RehoboamEngine {
  setEvents(events: readonly WorldEvent[]): void;
  setTheme(theme: RenderTheme): void;
  setInteraction(patch: Partial<InteractionState>): void;

  start(): void;
  stop(): void;

  resize(viewport: ViewportState): void;
  destroy(): void;
}
```

### Copy/paste prompts for agentic coding tools

Each prompt is intentionally scoped so a tool like Codex/Claude Code can execute without negotiation.

**Prompt: Implement polar math utilities**

- Goal: create robust polar conversions and angle helpers for ring layout and picking.
- Files: `src/shared/utils/math.ts`, `src/tests/layout/math.test.ts`
- Constraints: no DOM; pure functions only.
- Acceptance: unit tests cover angle normalization (wrap to `[0, 2π)`), shortest angular distance, cartesian↔polar conversion.
- Test expectations: Vitest tests pass. citeturn25search2

**Prompt: Implement Canvas2D rings pass**

- Goal: draw `ringCount` concentric rings with dash patterns and independent rotation.
- Files: `src/features/rehoboam/render/canvas2d/passes/ringsPass.ts`, `Renderer2D.ts`, tests in `src/tests/render/ringsPass.test.ts`
- Constraints: must use `setLineDash` + `lineDashOffset`; avoid shadowBlur on more than 3 rings per frame. citeturn23search3turn23search2
- Acceptance: rings animate at 60fps on typical hardware with `dpr<=2`; visually distinct layers.
- Test expectations: ringsPass produces deterministic “draw commands” snapshot (not pixel snapshot).

**Prompt: Implement event-to-angle layout**

- Goal: map events to angles on a rolling 24h window and compute marker heights by severity.
- Files: `src/features/rehoboam/layout/computeAngles.ts`, `src/tests/layout/computeAngles.test.ts`
- Constraints: stable ordering; identical inputs produce identical outputs.
- Acceptance: unit tests verify angle mapping at boundaries, clustering threshold, and severity scaling.

**Prompt: Implement hover + selection state machine**

- Goal: pointer hover selects nearest marker; click locks selection; Escape clears.
- Files: `src/features/rehoboam/engine/input.ts`, `RehoboamScene.tsx`
- Constraints: use Pointer Events; no mouse/touch split logic. citeturn18search3
- Acceptance: hovering changes `hoveredEventId` after dwell; click sets `selectedEventId`; Escape clears.
- Test expectations: state machine unit tests (no DOM).

**Prompt: Implement divergence waveform pass**

- Goal: draw a ring polyline with baseline ripple + localized pulse on new events.
- Files: `src/features/rehoboam/render/canvas2d/passes/divergencePass.ts`, tests in `src/tests/render/divergencePass.test.ts`
- Constraints: sample count adjustable; must complete in <3ms per frame at `S=360` on typical laptop.
- Acceptance: pulse envelope matches spec (attack/decay), and the pulse is localized by angular window. citeturn21search1
- Test expectations: deterministic output for fixed seed and fixed time steps.

**Prompt: Implement data normalization + dedupe**

- Goal: build `normalizeEvent()` and `dedupeEvents()` with stable IDs.
- Files: `src/features/rehoboam/data/normalize.ts`, `dedupe.ts`, `tests/data/*.test.ts`
- Constraints: must accept partial/messy inputs; must not throw on missing optional fields.
- Acceptance: duplicates removed; updates merge; normalized objects meet `WorldEvent` requirements.
- Test expectations: Vitest unit tests pass. citeturn25search2

**Prompt: Add IndexedDB persistence for events**

- Goal: persist normalized events and rehydrate on startup.
- Files: `src/features/rehoboam/data/store.ts`, `src/features/rehoboam/data/persistence.ts`
- Constraints: no external DB libs required; keep API minimal.
- Acceptance: on refresh, events load from IndexedDB immediately; network fetch updates later; app works offline with last cached state. citeturn19search5turn19search9
- Test expectations: mock persistence layer in unit tests.

**Prompt: Add Playwright visual regression test for the scene**

- Goal: create a deterministic “snapshot state” scene and assert screenshot stability.
- Files: `e2e/rehoboam.spec.ts`, `e2e/fixtures/mockEvents.json`
- Constraints: freeze time/seed; disable animations if needed; avoid flaky randomness.
- Acceptance: `expect(page).toHaveScreenshot()` passes locally and in CI. citeturn25search0turn25search21

## Testing, quality, and risks

### Testing strategy (lightweight but real)

**Unit tests (Vitest baseline)**

- Use entity["organization","Vitest","javascript testing framework"] for pure functions and state machines. citeturn25search2
- Focus areas:
  - geometry/polar math
  - event normalization/dedupe
  - layout mapping/clustering
  - interaction state machine

**Renderer invariants without pixel tests**

- Do not start with pixel-perfect tests inside jsdom; canvas support in jsdom is limited and often requires extra setup (node-canvas) and can be fragile. citeturn25search9turn25search3
- Instead: have render passes produce a debug list of “draw commands” (e.g., arcs, strokes, alphas, composite modes), and test those for determinism.

**Smoke tests**

- Start/stop engine does not leak RAF callbacks; resizing does not throw; setting events updates internal layout.

**Optional visual regression (recommended for this UI)**

- entity["organization","Playwright","browser automation framework"] supports screenshot comparisons with `expect(page).toHaveScreenshot()`, generating baselines then asserting diffs. citeturn25search0
- Use Playwright’s screenshot assertion behavior and options (e.g., waiting for stable rendering) to reduce flakiness. citeturn25search21

### Accessibility quality (realistic for a canvas-heavy UI)

- Provide non-visual equivalents: an event list panel with keyboard navigation and selection that mirrors the ring state.
- If you implement a custom listbox, follow WAI-ARIA listbox guidance (including `aria-activedescendant` patterns). citeturn24search3turn24search10
- For canvas itself, provide meaningful fallback or parallel DOM representation; HTML spec guidance explicitly frames canvas fallback content as the accessibility hook, and MDN emphasizes accessible fallback content for canvas media. citeturn24search17turn24search4

### Risks and mitigations

**Performance risk: too many rings + blur/glow**

- Mitigation: strict budgets (ringCount, waveSamples), limit shadowBlur usage, and bake noise tiles; consider OffscreenCanvas worker. citeturn17search0turn23search2turn18search12

**Complexity risk: building hit testing and interactions in canvas**

- Mitigation: keep actual click targets in DOM overlay; use canvas picking only for “nice-to-have” hover. Use Pointer Events for unified input. citeturn18search3turn24search4

**Cross-browser rendering risk: CSS filter quirks**

- Mitigation: prefer Canvas glow pass over heavy CSS `drop-shadow`; keep CSS filters minimal and optional. citeturn23search1turn23search28

**Data reliability risk: CORS + rate limits + inconsistent feeds**

- Mitigation: always support `mockEvents.json`; optionally adopt a tiny serverless aggregator to normalize and serve a single JSON endpoint; client caches via Cache API/IndexedDB. citeturn19search0turn19search5

**Scope creep risk: trying to match every on-screen detail**

- Mitigation: commit to the “layer primitives” approach and define a strict milestone gate: do not add a new visual trick unless it maps to a semantic (event, severity, category, selection state). This matches screen-graphics “hero vs atmosphere” discipline. citeturn4search0turn16view2

## Single Source of Truth Spec

This is the handoff block you can give to coding agents as-is.

**Objective**  
Build V2 of an existing React SPA “Rehoboam-inspired” circular UI. V2 must reproduce the recognizable grammar of Westworld’s Season 3-era divergence visuals: circular timeline, peaks/spikes representing divergences, labels with leader lines pointing to peaks, and system-state language (“Divergence/Anomaly/Elevated Scrutiny”)—implemented as a performant, testable, layered 2D renderer. citeturn14view0turn20view1turn9view1

**Non-goals**  
No copying show assets; no piracy; no full-stack rewrite; no mandatory backend.

**Rendering approach (default)**

- Hybrid: Canvas2D for rings/waves/markers; DOM (optional SVG) overlay for text/callouts/hit targets.
- Engine uses `requestAnimationFrame()` for motion, `ResizeObserver` for sizing, Pointer Events for input. citeturn18search0turn18search1turn18search3
- Optional: OffscreenCanvas worker renderer behind feature flag. citeturn17search0

**Layer order**

1. Background wash + grain (Canvas)
2. Base ring stack (Canvas, dashed + segmented arcs, multi-speed rotations)
3. Divergence waveform ring (Canvas polyline, localized pulses on event arrival)
4. Sweep/scan cue (Canvas)
5. Event markers as peaks on outer ring (Canvas)
6. Callouts + labels + hit targets (DOM/SVG overlay)

**Core tunables**  
Use the Parameter Table in the Visual Spec section; start with: `ringCount=22`, `eventMaxVisible=48`, divergence attack/decay (120ms/1400ms), `dprCap=2`.

**Data model**  
Use `WorldEvent` and related types exactly as defined in `src/features/rehoboam/engine/types.ts` (see earlier). Events must include: stable `id`, `title`, `timestampMs`, `category`, `severity` (0..1), `severityLabel`, `source`.

**Event mapping**

- Map events to ring angles (rolling time window or ordered “now” queue).
- Severity → peak height and pulse frequency.
- New event → marker insert animation + divergence waveform pulse at that angle.

**Repo architecture**  
Implement under `src/features/rehoboam/` with subfolders: `engine/`, `render/`, `layout/`, `data/`, `overlay/`. Keep pure math/layout in testable modules. Renderer should be a backend behind an interface so WebGL can be added later without refactoring.

**Testing**

- Unit tests in Vitest for math/layout/parsing/state. citeturn25search2
- Avoid early canvas pixel testing in jsdom; keep renderer deterministic via command snapshots. citeturn25search9
- Add Playwright screenshot test on a deterministic fixture state once visuals stabilize. citeturn25search0

**Accessibility**

- Provide an event list panel with keyboard navigation and selection mirroring ring selection. Follow WAI-ARIA listbox patterns where applicable. citeturn24search3turn24search10
- Ensure canvas has an accessible parallel DOM representation and/or meaningful fallback guidance per spec/doc recommendations. citeturn24search17turn24search4
